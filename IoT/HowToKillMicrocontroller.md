
Как штатными настройкаим убить микроконтроллер

![enter image description here](https://habrastorage.org/files/776/388/305/7763883051724bd4a7b1441fb3a18d7d.jpg)

Не могу назвать себя очень аккуратным и внимательным человеком, но, тем не менее, за более чем 10 лет разработки ПО для встраиваемых устройств мне толком не удалось ничего сжечь или испортить. С одной стороны, стоит за это сказать спасибо моим коллегам схемотехникам. С другой стороны, современная "умная" микроэлектроника имеет достаточно серьезную защиту от дурака. Но пару дней назад произошел один интересный случай. Мне удалось превратить в "кирпич" микроконтроллер Atmel SAMD21G18AU выполняя обычные манипуляции, описанные в user manual.

----------

Как то так получилось, что еще с институтских времен меня учили что "с Atmel работают одни дилетанты", по этому использовать его не стоит. Аргумент весьма сомнительный, но, по принципу "не читал но осуждаю", нелюбовь к Atmel передалась и ко мне. 

Однако, в один прекрасный момент, к нам пришел очередной заказчик и принес проект устройства, которое нужно доработать и для которого нужно написать "прошивку". Ядром этого устройства является микроконтроллер Atmel SAMD21G18AU. Так мне пришлось выкинуть свои предрассудки и начать изучать данный кристалл.

![enter image description here](https://habrastorage.org/files/00d/ae2/0e9/00dae20e97eb4196b6152dd1ffbb2553.jpg)

Микроконтроллер оказался достаточно известным и распространенным благодаря [ArduinoZero](https://www.arduino.cc/en/Main/ArduinoBoardZero). 

![enter image description here](https://habrastorage.org/files/7c4/1ff/40b/7c41ff40bffd44a7a75d4dd2aa4f910d.jpg)

После изучения общих параметров, я был очень впечатлен. Контроллер имеет мало общего со старыми атмеловскими семействами, работает на ядре Cortex M0 и использует мудреную систему конфигурации периферии, которой у него очень много.

![enter image description here](https://habrastorage.org/files/582/17c/9a0/58217c9a0fc44c4e894b1692dda8076c.jpg)

Эта система позволяет очень гибко настраивать кристалл под широкий круг задач, но она же и повышает его "сложность" и отрицательно влияет на кривую обучения работы с ним (Arduino IDE я в расчет не беру :). 

При этом, Atmel имеет собственную программную библиотеку для работы со своими микроконтроллерами [Atmel Software Framework](http://www.atmel.com/ru/ru/tools/avrsoftwareframework.aspx). Дело хорошее, до тех пор пока не начинаешь ей пользоваться :) Библиотека рассчитана для работы в IAR и Atmel Studio и содержит огромное количество драйверов, модулей и примеров почти для всех контроллеров Atmel... Но спроектирована и задокументирована она, на мой взгляд, достаточно плохо (попробуйте разобраться с [ней](http://asf.atmel.com/docs/latest/) что-нибудь сами)

Архитектура библиотеки спроектирована так, что все завязано на отладочные платы:

![enter image description here](https://habrastorage.org/files/886/3e4/443/8863e4443824401faf61a42e59216167.jpg)

То есть, чтобы использовать библиотеку для своей собственной платы, вам нужно сделать ее "описание" в определенном формате (весьма невнятно документированном) и поправить пару фалов (в частности board.h). При этом, если вы хотите просто взять конкретный драйвер и использовать его в своем проекте, то вы столкнетесь с приличными трудностями. Особенно, если ваш проект сделан не в IAR или Atmel Studio. Придется долго разгребать зависимости модулей и вычленять необходимые файлы.

Этот то процесс и погубил мой экземпляр контроллера. Мне нужен был драйвер Watchdog. Он, в свою очередь тянет несколько других драйверов, среди которых драйвер Clock, занимающийся настройкой тактовых генераторов как для ядра, так и для периферии. Ну а Clock использует специальный .h файл, содержащий конфигурацию генераторов для конкретного устройства. И мне так "повезло" что мне попался не тот файл, который в итоге отключил мне тактовый генератор ядра, а заодно и модуля для работы с SWD.

SAMD21G18AU имеет два встроенных тактовых генератора и позволяет использовать два внешних. Модуль GENERIC CLOCK CONTROLLER имеет в своем составе несколько внутренних генераторов. Первый из них тактирует ядро, остальные можно использовать для тактирования периферии. Для каждого внутреннего генератора можно задать источник (внутренний или внешний), множитель и другие параметры, среди которых есть "OnDemand". Он позволяет запускать генератор "по требованию", тем самым уменьшая потребление системы.

![enter image description here](https://habrastorage.org/files/dc7/e60/c10/dc7e60c1092448fba6a98025028a251c.jpg)

После перезагрузки SAMD21G18AU по умолчанию настраивает работу ядра от внутреннего генератора на 8 МГц, а остальные генераторы отключает. 

Файл, который попался мне, заставляет драйвер Clock настроить тактирование ядра на внутренний 8 МГц генератор, но при этом переводит его в режим "OnDemand". Но этот режим почему-то не срабатывает и генератор не заводится. Получается что как только контроллер начинает выполнять код, он отключает себе тактирование. 

При этом, модуль работы с SWD тоже перестает тактироваться, а значит и перестает отвечать при попытке соединения. И никакие ухищрения не помогают поймать момент, когда процессор уже включился, но еще не успел отработать кривую настройку модуля GENERIC CLOCK CONTROLLER.

Можно было бы воспользоваться перепрошивкой через bootloader. Обычно в микроконтроллерах есть "зашитый" загрузчик, позволяющий программировать его как минимум через COM-порт. Но не тут-то было! Atmel перехитрил сам себя. Использование bootloadr'а то [предусмотрено](http://www.atmel.com/images/atmel-42366-sam-ba-bootloader-for-sam-d21_applicationnote_at07175.pdf), но из-за "гибкости" в настройках место, зарезервированное под него, может быть использовано для хранения исполняемого кода. И похоже, это является настройкой по умолчанию.

То есть, чтобы работать с bootloader'ом, его нужно сначала "зашить" в контроллер. И конечно, в моем случае, это сделано не было.

Самое забавное, что на плате распаяны оба внешних кварца, но в итоге ни один не работает. Подступиться к контроллеру не получается ни через SWD, ни через Bootloader.

В заключении истории хочу сказать, что я все-таки не обладаю очень глубокими навыками работы с данным микроконтроллером, по этому, возможно, есть способ его оживить. Может быть кто-то мне подскажет решение проблемы, пока мы не отпаяли "кирпич" и не припаяли новый SAMD21G18AU?

p.s. Ну а моя нелюбовь к Atmel получила первый аргумент в свою пользу. Контроллер, позволяющий загнать себя в тупик комбинацией настроек, при этом не имеющий штатных средств восстановления - это как-то не солидно...
